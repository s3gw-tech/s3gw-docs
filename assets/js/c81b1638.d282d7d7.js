"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8031],{9833:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var s=t(4848),i=t(8453);const o={},r="s3gw Storage Backend",l={id:"0002-s3gw-storage-backend",title:"s3gw Storage Backend",description:"Context and Problem Statement",source:"@site/../s3gw/docs/decisions/0002-s3gw-storage-backend.md",sourceDirName:".",slug:"/0002-s3gw-storage-backend",permalink:"/decisions/0002-s3gw-storage-backend",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"decisions",previous:{title:"Reorganize Documentation",permalink:"/decisions/0001-reorganize-documentation"},next:{title:"SFS SAL Backend Design",permalink:"/decisions/0003-sfs"}},c={},d=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Decision Drivers",id:"decision-drivers",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"We don&#39;t need transactions",id:"we-dont-need-transactions",level:3},{value:"Positive Consequences",id:"positive-consequences",level:2},{value:"Negative Consequences",id:"negative-consequences",level:2},{value:"Pros and Cons of the Options",id:"pros-and-cons-of-the-options",level:2},{value:"SAL dbstore",id:"sal-dbstore",level:3},{value:"Ceph OSD ObjectStore",id:"ceph-osd-objectstore",level:3},{value:"Forked Filestore",id:"forked-filestore",level:3}];function a(e){const n={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"s3gw-storage-backend",children:"s3gw Storage Backend"}),"\n",(0,s.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,s.jsx)(n.p,{children:"How to store RGW data without RADOS? What are our options? How to\nwork well on Longhorn?"}),"\n",(0,s.jsx)(n.h2,{id:"decision-drivers",children:"Decision Drivers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Performance"}),"\n",(0,s.jsx)(n.li,{children:"Works well on Longhorn and NVMe"}),"\n",(0,s.jsx)(n.li,{children:"Versioned buckets"}),"\n",(0,s.jsx)(n.li,{children:"Efficient copy between buckets"}),"\n",(0,s.jsx)(n.li,{children:"Efficient large file handling"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,s.jsx)(n.p,{children:"RGW SAL backends:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"RGW dbstore. Used in our first MVP release"}),"\n",(0,s.jsx)(n.li,{children:"Ceph OSD ObjectStore (OS) (FileStore or Blue Store)"}),"\n",(0,s.jsx)(n.li,{children:"Forked FileStore"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"sfs"})," - SQLite with custom filesystem store"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,s.jsx)(n.p,{children:'Chosen option: "sfs", because'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ceph OS is not a good fit. Transactions are nice, but we don't need\nthem and certainly don't want to pay for them."}),"\n",(0,s.jsx)(n.li,{children:"RGW dbstore is an option, but storing object data in SQLite fails\nour efficiency and performance requirements"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"we-dont-need-transactions",children:"We don't need transactions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We can serialize using SQLite if we need to"}),"\n",(0,s.jsx)(n.li,{children:"We only store immutable data to disk. Since we assume fast storage,\nwe can wait for durable fsynced writes."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"positive-consequences",children:"Positive Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We will create knowledge on the data path in the team"}),"\n",(0,s.jsx)(n.li,{children:"We won't have mutability code paths that we don't need"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"negative-consequences",children:"Negative Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We start from scratch. We have to deal with the intricacies of\nstorage devices and their failure models."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"pros-and-cons-of-the-options",children:"Pros and Cons of the Options"}),"\n",(0,s.jsx)(n.h3,{id:"sal-dbstore",children:"SAL dbstore"}),"\n",(0,s.jsx)(n.p,{children:"SAL dbstore is an upstream WIP project. Everything in SQLite."}),"\n",(0,s.jsx)(n.h3,{id:"ceph-osd-objectstore",children:"Ceph OSD ObjectStore"}),"\n",(0,s.jsx)(n.p,{children:"Leverage the OSD ObjectStore. The SAL backend would be a translation\nlayer from RGW objects and buckets to OS collections and objects. The\nOS API is transaction based and supports in place updates."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/irq0/ceph/tree/wip/rgw-filestore",children:"PoC code"}),"\nPoC uses the OS abstraction, but only supports FileStore not BlueStore."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good, because OS is battle tested"}),"\n",(0,s.jsx)(n.li,{children:"Good, because we don't need to implement our own efficient low level\nfile handling and error management code."}),"\n",(0,s.jsx)(n.li,{children:"Good, because with filestore we get a hash directory tree\nimplementation"}),"\n",(0,s.jsx)(n.li,{children:"Neutral, because we get transactions"}),"\n",(0,s.jsx)(n.li,{children:"Neutral, because we could leverage RGW object classes"}),"\n",(0,s.jsx)(n.li,{children:"Bad, because the OS collection abstractions (PGs, etc) do not fit\nthe RGW S3 model"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"forked-filestore",children:"Forked Filestore"}),"\n",(0,s.jsx)(n.p,{children:"A big problem with the OS approach above was the mismatch in the\ncollections abstractions. A way around this is to fork filestore and\nreplace coll_t, hobject_t and the like with our own types."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/irq0/ceph/tree/wip/rgw-filestore-fork",children:"PoC Code"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good, because we have the freedom to adjust filestore to our needs"}),"\n",(0,s.jsx)(n.li,{children:"Neutral, because we no longer follow the upstream filestore progress.\nFilestore is deprecated - This could be a new life as SAL backend."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);