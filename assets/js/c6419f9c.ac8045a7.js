"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4424],{3580:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=t(4848),i=t(8453);const o={},r="SFS Versioning",a={id:"0010-sfs-versioning",title:"SFS Versioning",description:"Refines ADR 0003-SFS on the object state machine and database columns.",source:"@site/../s3gw/docs/decisions/0010-sfs-versioning.md",sourceDirName:".",slug:"/0010-sfs-versioning",permalink:"/decisions/0010-sfs-versioning",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"decisions",previous:{title:"Collection of High Level Design Decisions",permalink:"/decisions/0009-sfs-collection-of-high-level-design-decisions"},next:{title:"SFS Timestamps",permalink:"/decisions/0011-sfs-timestamps"}},d={},c=[{value:"Database",id:"database",level:2},{value:"Object State Machine",id:"object-state-machine",level:2},{value:"Timestamps",id:"timestamps",level:2},{value:"Object Version Types",id:"object-version-types",level:2},{value:"Garbage Collection",id:"garbage-collection",level:2},{value:"Operations",id:"operations",level:2},{value:"Deletion",id:"deletion",level:3},{value:"Hiding / Deletion Marker",id:"hiding--deletion-marker",level:3},{value:"Create / Update",id:"create--update",level:3},{value:"Access: Listing, GETs",id:"access-listing-gets",level:3},{value:"Out of scope (for now): Versioning Suspended Buckets",id:"out-of-scope-for-now-versioning-suspended-buckets",level:3}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"sfs-versioning",children:"SFS Versioning"}),"\n",(0,s.jsx)(n.p,{children:"Refines ADR 0003-SFS on the object state machine and database columns."}),"\n",(0,s.jsx)(n.h2,{id:"database",children:"Database"}),"\n",(0,s.jsx)(n.p,{children:"In this document we only look at tables Objects and Versioned Objects."}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.em,{children:"object"})," has a name, id, and reference to a ",(0,s.jsx)(n.em,{children:"bucket"})]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"object version"})," has an id, checksum, {create, commit, delete}_time,\nmtime, size, ",(0,s.jsx)(n.strong,{children:"state"}),", ",(0,s.jsx)(n.strong,{children:"type"}),", ETag, serialized attributes, etc."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.em,{children:"object"})," is a group of versions identified by bucket and name."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.em,{children:"object"})," has one or more ",(0,s.jsx)(n.em,{children:"object versions"}),". Regardless of the bucket versioning setting."]}),"\n",(0,s.jsxs)(n.p,{children:["Object ",(0,s.jsx)(n.strong,{children:"state"})," is an enum of Open, Committed, Deleted. See Object State Machine."]}),"\n",(0,s.jsxs)(n.p,{children:["Object ",(0,s.jsx)(n.strong,{children:"type"})," is an enum of Regular, Delete Marker."]}),"\n",(0,s.jsx)(n.h2,{id:"object-state-machine",children:"Object State Machine"}),"\n",(0,s.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e Open : Create new version\n    Open --\x3e Committed : Success\n    Open --\x3e Open : Writing\n    Committed --\x3e Deleted : Delete\n    Open --\x3e [*] : Failure\n    Deleted --\x3e [*] : Garbage Collection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Open"})," - Initial state. Data is in flight. Data on disk is dirty. A\nversion may stay in this state if, for example, a client fails during\na PUT operation. A to be defined GC process cleans this up after a\ntime."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Committed"})," - Upload finished. Data persisted. GETs and LIST\nwill return this object."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Deleted"})," - Soft deletion state, but in terms of S3 permanent deletion."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"terminal state"})," - the row no longer exists in the database."]}),"\n",(0,s.jsx)(n.p,{children:"An object will never move back from Deleted to Committed. Deleting a\nversion is treated as permanent, even though it is only permanent after\nthe GC made it so."}),"\n",(0,s.jsx)(n.p,{children:"State changes also change timestamps:"}),"\n",(0,s.jsx)(n.h2,{id:"timestamps",children:"Timestamps"}),"\n",(0,s.jsx)(n.p,{children:"(See ADR 11 for information on the data type we store)"}),"\n",(0,s.jsx)(n.p,{children:"Versioned objects store the following timestamps:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"commit_time"})," - When the object changes to ",(0,s.jsx)(n.em,{children:"Committed"})," state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"delete_time"})," - When the object changes to ",(0,s.jsx)(n.em,{children:"Deleted"})," state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"create_time"})," - Set when the row is first created in ",(0,s.jsx)(n.em,{children:"Open"})," state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"mtime"})," - A modification time passed to SFS. We follow the RADOS\nlogic: Passed a ",(0,s.jsx)(n.code,{children:"set_mtime"})," and ",(0,s.jsx)(n.code,{children:"mtime"}),", we persist ",(0,s.jsx)(n.code,{children:"set_mtime"}),". If\n",(0,s.jsx)(n.code,{children:"is_zero(set_mtime)"})," we take ",(0,s.jsx)(n.code,{children:"real_clock::now()"}),". Return the ",(0,s.jsx)(n.code,{children:"mtime"}),"\nwe persisted."]}),"\n",(0,s.jsx)(n.h2,{id:"object-version-types",children:"Object Version Types"}),"\n",(0,s.jsxs)(n.p,{children:["An object version may be of special type ",(0,s.jsx)(n.em,{children:"delete marker"}),", representing\nan S3 delete marker in versioned buckets."]}),"\n",(0,s.jsx)(n.h2,{id:"garbage-collection",children:"Garbage Collection"}),"\n",(0,s.jsx)(n.p,{children:"Input: object versions in deleted state."}),"\n",(0,s.jsx)(n.p,{children:"Either delete single versions or delete whole objects."}),"\n",(0,s.jsx)(n.p,{children:"In case whole objects, delete the object row if all versions are deleted.\nIn a transaction delete all versions, then the object."}),"\n",(0,s.jsx)(n.p,{children:"Should a concurrent transaction add a new version either will fail on\nthe foreign key constraint between version and object. In the GC we\ncontinue with the next object; in the create path we retry or let the\nclient retry."}),"\n",(0,s.jsx)(n.h2,{id:"operations",children:"Operations"}),"\n",(0,s.jsx)(n.h3,{id:"deletion",children:"Deletion"}),"\n",(0,s.jsx)(n.p,{children:"Deleting a version is not to be confused with hiding objects by adding\ndeletion markers. Deleting an object sets the state to DELETED."}),"\n",(0,s.jsx)(n.h3,{id:"hiding--deletion-marker",children:"Hiding / Deletion Marker"}),"\n",(0,s.jsx)(n.p,{children:"A delete to a versioned bucket without a version creates a delete\nmarker. This hides the object and all its version from unversioned GETs\nand LISTS."}),"\n",(0,s.jsx)(n.p,{children:"SFS implements this with object versions having type delete marker. If\none exists on an object, it is excluded."}),"\n",(0,s.jsx)(n.p,{children:"Deletion markers are object versions and follow the same state machine\nand garbage collection as regular versions do. They however don't have\na size and data on the filesystem."}),"\n",(0,s.jsx)(n.h3,{id:"create--update",children:"Create / Update"}),"\n",(0,s.jsx)(n.p,{children:"(versioned, unversioned buckets) In a transaction:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Find or create an object row (id, name, bucket)"}),"\n",(0,s.jsx)(n.li,{children:"Create an object version in state OPEN with creation time of now.\nIf versioned, use the version id provided. Otherwise generate one."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Receive and write data."}),"\n",(0,s.jsx)(n.p,{children:"On completion:\n(versioned buckets) set state COMMITTED of the previously created version. Record\nchecksum, size, etc."}),"\n",(0,s.jsx)(n.p,{children:"(unversioned buckets) set state COMMITTED of the previously created version\nAND set all other versions DELETED."}),"\n",(0,s.jsx)(n.h3,{id:"access-listing-gets",children:"Access: Listing, GETs"}),"\n",(0,s.jsxs)(n.p,{children:['Many operations expect a head, null, last or "canonical" version of\nan object. We define this as the ',(0,s.jsx)(n.em,{children:"last"})," committed version, having the ",(0,s.jsx)(n.em,{children:"latest"}),"\n",(0,s.jsx)(n.em,{children:"commit_time"})," timestamp."]}),"\n",(0,s.jsx)(n.p,{children:"If the timestamp resolution is too low to distinguish versions the highest id wins."}),"\n",(0,s.jsx)(n.p,{children:"(unversioned) Since we rely on versions to implement updates, more\nthan one committed version may exist. We make this less likely by the commit rule in\nCreate / Update above. Should multiple exists, the latest is the one we use."}),"\n",(0,s.jsx)(n.h3,{id:"out-of-scope-for-now-versioning-suspended-buckets",children:"Out of scope (for now): Versioning Suspended Buckets"}),"\n",(0,s.jsx)(n.p,{children:"For now SFS won't support versioning suspended buckets. Object\nversions created while the bucket was unversioned or in versioning\nsuspended state have a 'null' version id. This is not directly\nsupported by this design and requires refinement in the future."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);