"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3731],{1059:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=n(4848),o=n(8453);const i={},a="s3gw-ui backend API",r={id:"0014-ui-backend-api",title:"s3gw-ui backend API",description:"Using POST instead of GET for some operations",source:"@site/../s3gw/docs/decisions/0014-ui-backend-api.md",sourceDirName:".",slug:"/0014-ui-backend-api",permalink:"/decisions/0014-ui-backend-api",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{},sidebar:"decisions",previous:{title:"s3gw-ui backend",permalink:"/decisions/0013-ui-backend"},next:{title:"Release Methodology for the s3gw project",permalink:"/decisions/0015-release-methodology"}},h={},d=[{value:"Using POST instead of GET for some operations",id:"using-post-instead-of-get-for-some-operations",level:2},{value:"Versioning",id:"versioning",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"s3gw-ui-backend-api",children:"s3gw-ui backend API"}),"\n",(0,s.jsx)(t.h2,{id:"using-post-instead-of-get-for-some-operations",children:"Using POST instead of GET for some operations"}),"\n",(0,s.jsx)(t.p,{children:"While we should strive to ensure that we are compliant with the RESTful API\nparadigm, in some instances this is not viable."}),"\n",(0,s.jsxs)(t.p,{children:["One such instance is when we have a lot of information that needs to be provided\nto the API during a GET call. In such a situation it would make sense to rely on\nthe GET request's body to pass the additional context we need, but unfortunately\nbrowsers tend to drop the body for GET requests before sending the request to\nthe server (",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send",children:"1"})," ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET",children:"2"})," ",(0,s.jsx)(t.a,{href:"https://xhr.spec.whatwg.org/#the-send()-method",children:"3"}),")."]}),"\n",(0,s.jsx)(t.p,{children:"We are left with one of the following options:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Pass all the information we need as query parameters during the GET call"}),"\n",(0,s.jsx)(t.li,{children:"Pass additional parameters in the HTTP request's headers"}),"\n",(0,s.jsx)(t.li,{children:"Use another operation, instead of GET, to pass the additional information to\nthe server in the request's body."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The first approach has the downside that we are limited to a predefined hard\nlimit of characters in the URL, which is browser dependent. For instance, Chrome\nis limited to 2083 characters, while Firefox is limited to 65536 characters. We\nmust thus assume the lower bound, being effectively limited to 2083 characters."}),"\n",(0,s.jsx)(t.p,{children:"Given some operations require object names to be provided, and given S3 object\nnames may have up to 1024 characters, we become slightly limited in the number\nof remaining characters available for additional parameters. Additionally, the\nS3 protocol allows object names to contain certain characters that are\nconsidered reserved for URLs, meaning we would have to URL-encode them, putting\nadditional pressure on the limit we have already established. In the worst case\nscenario, an object name composed solely of reserved characters would take three\ntimes as many characters after being URL-encoded than its original form. That by\nitself is more than the available characters we have for a URL if the object has\nthe maximum number of allowed characters of 1024."}),"\n",(0,s.jsx)(t.p,{children:"The second approach, we believe, is less obvious. Could we pass these values as\nHTTP headers? We think so. But we find that ugly and not at all obvious. It\nwould mean passing potentially huge payloads in the header, and that's the bit\nwe find ugly; it's not obvious because headers are not exactly the first place\none would think to look into for large payloads."}),"\n",(0,s.jsx)(t.p,{children:"We are thus left with the third option. By using a different operation for which\nthe request's body is not stripped away, we can provide as much context as we\nwant or need to the server, with little to no modification of the original\npayload."}),"\n",(0,s.jsx)(t.p,{children:"Therefore, we have chosen to use POST operations for selected operations that\nare semantically the equivalent to a GET operation. This breaks the RESTfulness\nof our API for some operations, but we believe this to be a reasonable tradeoff."}),"\n",(0,s.jsx)(t.h2,{id:"versioning",children:"Versioning"}),"\n",(0,s.jsxs)(t.p,{children:["Versioning of an API makes sense if it is public, but the UI backend API is\nnot meant for public use. Since the UI and the associated backend REST API\nare always delivered together and are therefore tightly coupled, there is no\nreal API versioning required. Nevertheless, for certain situations a simple\nAPI versioning is needed.\nTo prevent situations where the UI does not know that the API and its behavior\nhas changed, a custom header ",(0,s.jsx)(t.code,{children:"S3GW-Accept-Version: X.Y.Z"})," is sent along.\nThis  version is incremented in case of serious changes to the API. If the\nclient sends a request with an API version unknown on the server, it will be\nrejected with an error. If the custom header is not sent, then no check is\nperformed on the server side."]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);