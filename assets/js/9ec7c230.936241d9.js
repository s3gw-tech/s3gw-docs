"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5409],{2788:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var i=s(4848),t=s(8453);const r={},o="SFS Timestamps",c={id:"0011-sfs-timestamps",title:"SFS Timestamps",description:"Context and Problem Statement",source:"@site/../s3gw/docs/decisions/0011-sfs-timestamps.md",sourceDirName:".",slug:"/0011-sfs-timestamps",permalink:"/decisions/0011-sfs-timestamps",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{},sidebar:"decisions",previous:{title:"SFS Versioning",permalink:"/decisions/0010-sfs-versioning"},next:{title:"SFS Error Handling",permalink:"/decisions/0012-sfs-error-handling"}},l={},d=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Ceph time",id:"ceph-time",level:2},{value:"How to store time in SQLite",id:"how-to-store-time-in-sqlite",level:2},{value:"Requirements",id:"requirements",level:3},{value:"Considered Options",id:"considered-options",level:3},{value:"Decision Outcome",id:"decision-outcome",level:3}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"sfs-timestamps",children:"SFS Timestamps"}),"\n",(0,i.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,i.jsx)(n.p,{children:"We need to create, handle and persist timestamps."}),"\n",(0,i.jsx)(n.p,{children:"In the RGW space we have ceph_time.h and std::chrono."}),"\n",(0,i.jsxs)(n.p,{children:["SQLite represents time as ISO-8601, Julian day or unix timestamps.\nStored in TEXT, REAL or INTEGER data types. ",(0,i.jsx)(n.a,{href:"https://www.sqlite.org/datatype3.html",children:"SQLite doc:\ndata types"}),". It has functions to\nwork with these data types. ",(0,i.jsx)(n.a,{href:"https://www.sqlite.org/lang_datefunc.html",children:"SQLite doc:\ndatefunc"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This doc is about the conversion between RGW/sfs and SQLite space."}),"\n",(0,i.jsxs)(n.p,{children:["Summary of discussion in weeks 19, 20 2023. ",(0,i.jsx)(n.a,{href:"https://github.com/aquarist-labs/s3gw/pull/497",children:"GH\nComments"})]}),"\n",(0,i.jsx)(n.h2,{id:"ceph-time",children:"Ceph time"}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:"ceph::real_time"})," as timestamps."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ceph::real_time"})," is a ",(0,i.jsx)(n.code,{children:"uint64_t"})," nanosecond count since epoch."]}),"\n",(0,i.jsx)(n.h2,{id:"how-to-store-time-in-sqlite",children:"How to store time in SQLite"}),"\n",(0,i.jsx)(n.h3,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsx)(n.p,{children:"Minimum microsecond resolution."}),"\n",(0,i.jsx)(n.p,{children:"We can leverage SQLIte range queries, sorting, indices. Ideally we can\nleverage date / time functions with minor conversion."}),"\n",(0,i.jsx)(n.h3,{id:"considered-options",children:"Considered Options"}),"\n",(0,i.jsx)(n.p,{children:"Options, that don't fit our requirements:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"ISO8601"})," strings. Not enough resolution."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"UNIX time"})," - Not enough resolution"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"multicol"})," - Store seconds as ",(0,i.jsx)(n.em,{children:"ISO8601"})," or ",(0,i.jsx)(n.em,{children:"UNIX time"})," (SQLite\nfunctions work directly). Store nanoseconds in a second column.\nQueries awkward."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"int64 ns"})," - Store as int64, nanosecond resolution, convert from\nuint64. Max value up to year 2262. Queries work."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"int64 us"})," - Store as int64, microsecond resolution, convert from\nuint64. Max value up to year 2554. Queries work."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"hex"})," - Store as 16 char hex string. Full ",(0,i.jsx)(n.code,{children:"ceph::real_time"})," range.\nConversion cost. Queries work."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"uint64"})," - Squeeze ",(0,i.jsx)(n.code,{children:"uint64_t"})," into SQLite ",(0,i.jsx)(n.code,{children:"INTEGER"})," type\nrepresentation. No queries."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"blob"})," - Store ",(0,i.jsx)(n.code,{children:"ceph::real_time"})," as an SQLite blob. Can't query and\nindex as easily as ",(0,i.jsx)(n.em,{children:"hex"})," or ",(0,i.jsx)(n.em,{children:"int64"})," options."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,i.jsxs)(n.p,{children:["We choose ",(0,i.jsx)(n.em,{children:"int64 ns"}),", because it meets all criteria."]}),"\n",(0,i.jsx)(n.p,{children:"It requires minimal conversion. We can live with the year 2262\nlimitation."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);