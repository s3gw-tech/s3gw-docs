"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7081],{321:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var n=t(4848),i=t(8453);const o={},l="Collection of High Level Design Decisions",r={id:"0009-sfs-collection-of-high-level-design-decisions",title:"Collection of High Level Design Decisions",description:"Use soft deletion. Mark versions deleted, let a garbage collector hard",source:"@site/../s3gw/docs/decisions/0009-sfs-collection-of-high-level-design-decisions.md",sourceDirName:".",slug:"/0009-sfs-collection-of-high-level-design-decisions",permalink:"/decisions/0009-sfs-collection-of-high-level-design-decisions",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{},sidebar:"decisions",previous:{title:"Pull Requests and Code Review Guide",permalink:"/decisions/0008-pull-requests-code-review-guide"},next:{title:"SFS Versioning",permalink:"/decisions/0010-sfs-versioning"}},a={},c=[];function d(e){const s={em:"em",h1:"h1",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"collection-of-high-level-design-decisions",children:"Collection of High Level Design Decisions"}),"\n",(0,n.jsxs)(s.p,{children:["Use soft deletion. Mark versions deleted, let a garbage collector hard\ndelete ",(0,n.jsx)(s.em,{children:"later"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"Non-versioned objects are a special case of versioned objects. They\ngenerally follow the same logic."}),"\n",(0,n.jsx)(s.p,{children:"The SFS SQLite database is the source of truth. Example: If we delete\nan object, we first modify the database then the filesystem. Example:\nServe metadata (object size, mtime, ..) from the database rather\nthan stat() the file."}),"\n",(0,n.jsx)(s.p,{children:"SQLite transactions are atomic. Filesystem operations maybe. Both combined are not.\nOrphaned files on the filesystem are acceptable and countered by an offline fsck tool."}),"\n",(0,n.jsx)(s.p,{children:"Use Ceph bufferlist encodings of data structures in the database where\nwe don't have to query individual fields. Example: object attrs is\nbufferlist encoded, deletion time is not. With this leverage Ceph data\nstructure versioning support as much as possible."}),"\n",(0,n.jsx)(s.p,{children:"Use negative return value style error handling not exceptions. This\nfollows from the Google C++ style guide and the general RGW style."})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>l,x:()=>r});var n=t(6540);const i={},o=n.createContext(i);function l(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);